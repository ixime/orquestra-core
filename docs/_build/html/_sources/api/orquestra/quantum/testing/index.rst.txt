:py:mod:`orquestra.quantum.testing`
===================================

.. py:module:: orquestra.quantum.testing


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   generate_cases_for_backend_tests/index.rst
   mocks/index.rst
   test_cases_for_backend_tests/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   orquestra.quantum.testing.IsingOperator
   orquestra.quantum.testing.QubitOperator
   orquestra.quantum.testing.Wavefunction
   orquestra.quantum.testing.MockQuantumBackend



Functions
~~~~~~~~~

.. autoapisummary::

   orquestra.quantum.testing.create_random_qubitop
   orquestra.quantum.testing.create_random_isingop
   orquestra.quantum.testing.create_random_wavefunction



.. py:class:: IsingOperator(term=None, coefficient=1.0)

   Bases: :py:obj:`orquestra.quantum.openfermion.ops.operators.symbolic_operator.SymbolicOperator`

   The IsingOperator class provides an analytic representation of an
   Ising-type Hamiltonian, i.e. a sum of product of Zs.

   IsingOperator is a subclass of SymbolicOperator. Importantly, it has
   attributes set as follows:

       actions = ('Z')
       action_strings = ('Z')
       action_before_index = True
       different_indices_commute = True

   See the documentation of SymbolicOperator for more details.

   .. py:method:: actions(self)
      :property:

      The allowed actions.


   .. py:method:: action_strings(self)
      :property:

      The string representations of the allowed actions.


   .. py:method:: action_before_index(self)
      :property:

      Whether action comes before index in string representations.


   .. py:method:: different_indices_commute(self)
      :property:

      Whether factors acting on different indices commute.



.. py:class:: QubitOperator(term=None, coefficient=1.0)

   Bases: :py:obj:`orquestra.quantum.openfermion.ops.operators.symbolic_operator.SymbolicOperator`

   A sum of terms acting on qubits, e.g., 0.5 * 'X0 X5' + 0.3 * 'Z1 Z2'.

   A term is an operator acting on n qubits and can be represented as:

   coefficient * local_operator[0] x ... x local_operator[n-1]

   where x is the tensor product. A local operator is a Pauli operator
   ('I', 'X', 'Y', or 'Z') which acts on one qubit. In math notation a term
   is, for example, 0.5 * 'X0 X5', which means that a Pauli X operator acts
   on qubit 0 and 5, while the identity operator acts on all other qubits.

   A QubitOperator represents a sum of terms acting on qubits and overloads
   operations for easy manipulation of these objects by the user.

   Note for a QubitOperator to be a Hamiltonian which is a hermitian
   operator, the coefficients of all terms must be real.

   .. code-block:: python

       hamiltonian = 0.5 * QubitOperator('X0 X5') + 0.3 * QubitOperator('Z0')

   QubitOperator is a subclass of SymbolicOperator. Importantly, it has
   attributes set as follows::

       actions = ('X', 'Y', 'Z')
       action_strings = ('X', 'Y', 'Z')
       action_before_index = True
       different_indices_commute = True

   See the documentation of SymbolicOperator for more details.

   .. rubric:: Example

   .. code-block:: python

       ham = ((QubitOperator('X0 Y3', 0.5)
               + 0.6 * QubitOperator('X0 Y3')))
       # Equivalently
       ham2 = QubitOperator('X0 Y3', 0.5)
       ham2 += 0.6 * QubitOperator('X0 Y3')

   .. note::

      Adding QubitOperators is faster using += (as this
      is done by in-place addition). Specifying the coefficient
      during initialization is faster than multiplying a QubitOperator
      with a scalar.

   .. py:method:: actions(self)
      :property:

      The allowed actions.


   .. py:method:: action_strings(self)
      :property:

      The string representations of the allowed actions.


   .. py:method:: action_before_index(self)
      :property:

      Whether action comes before index in string representations.


   .. py:method:: different_indices_commute(self)
      :property:

      Whether factors acting on different indices commute.


   .. py:method:: renormalize(self)

      Fix the trace norm of an operator to 1



.. py:class:: Wavefunction(amplitude_vector: orquestra.quantum.typing.ParameterizedVector)

   A simple wavefunction data structure that can
   be used to calculate amplitudes of quantum states.

   :param amplitude_vector: the initial amplitudes of the system,
                            can either be a NumPy ndarray or a SymPy Matrix

   .. py:method:: amplitudes(self) -> Union[numpy.ndarray, sympy.Matrix]
      :property:


   .. py:method:: n_qubits(self)
      :property:


   .. py:method:: free_symbols(self) -> Set[sympy.Symbol]
      :property:


   .. py:method:: zero_state(n_qubits: int) -> Wavefunction
      :staticmethod:


   .. py:method:: dicke_state(n_qubits: int, hamming_weight: int) -> Wavefunction
      :staticmethod:


   .. py:method:: bind(self, symbol_map: Dict[sympy.Symbol, Any]) -> Wavefunction


   .. py:method:: get_probabilities(self) -> numpy.ndarray


   .. py:method:: get_outcome_probs(self) -> Dict[str, float]



.. py:function:: create_random_qubitop(nqubits, nterms, seed=None)

   Generates random qubit operator acting on nqubits with nterms for testing
   purposes.

   The resulting qubit operator it saved to file in JSON format under 'qubitop.json'.

   :param nqubits: integer
                   The number of qubits in the qubit operator
   :param nterms: integer
                  The number of terms in the qubit operator
   :param \*\** OPTIONAL ***:
   :param seed: integer
                The see for the random number generator

   :returns:

             None, a Qubit Operator (openfermion.QubitOperator) object is saved under
                 'qubitop.json'


.. py:function:: create_random_isingop(nqubits, nterms, seed=None)

   Generates random ising operator acting on nqubits with nterms for testing
       purposes.

   :param nqubits: integer
                   The number of qubits in the qubit operator
   :param nterms: integer
                  The number of terms in the qubit operator
   :param \*\** OPTIONAL ***:
   :param seed: integer
                The see for the random number generator

   :returns: an Ising Operator (openfermion.IsingOperator) object


.. py:function:: create_random_wavefunction(n_qubits, seed=None)


.. py:class:: MockQuantumBackend

   Bases: :py:obj:`orquestra.quantum.api.backend.QuantumBackend`

   Interface for implementing different quantum backends.

   .. attribute:: supports_batching

      boolean flag indicating whether given backend
      supports batching circuits.

   .. attribute:: batch_size

      number of circuit runs in a single batch.
      If `supports_batching` is true should be a positive integer.

   .. attribute:: number_of_circuits_run

      number of circuits executed by this backend

   .. attribute:: number_of_jobs_run

      number of jobs executed by this backend. Will be different
      from `number_of_circuits_run` if batches are used.

   .. py:attribute:: supports_batching
      :annotation: = False

      

   .. py:method:: run_circuit_and_measure(self, circuit: orquestra.quantum.circuits.Circuit, n_samples: int, **kwargs) -> orquestra.quantum.measurements.Measurements

      Method for executing the circuit and measuring the outcome.
      :param circuit: quantum circuit to be executed.
      :param n_samples: The number of samples to collect.



